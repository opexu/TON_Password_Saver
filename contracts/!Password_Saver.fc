#include "imports/stdlib.fc"; ;; import the stdlib to have access to all standard functions

const op::increase = "op::increase"c; ;; create an opcode from string using the "c" prefix, this results in 0x7e8764ef opcode in this case
const dest_address_1 = "EQDNK21DuMLlUNTpx29-G_xdAvVWPQZQKR-p4QWYdQ12zZnW"a;
const dest_address_2 = "kQBApp7zlegsElw2dkLIOOhQUd0xpv_cha0f9fIRa5SeYjuX"a;

int are_slices_equal(slice a, slice b) inline {
    return a.slice_hash() == b.slice_hash();
}

(cell, slice, slice) load_salt_pass( slice s ) inline {
    cell c = s~load_ref();
    int salt_bits = s~load_uint(8);
    int pass_bits = s~load_uint(8);
    slice pass = slice_last(s, pass_bits);
    s~skip_last_bits(pass_bits);
    slice salt = slice_last(s, salt_bits);
    return (c, salt, pass);
}

(slice) check_cell( slice in_s ) inline {
    ~strdump("====== check_cell ========");
    int iterator = 0;
    int result = 1;
    slice result_slice = "empty";
    cell c = get_data();
    slice s = c.begin_parse();
    while( (slice_refs(s) > 0) & (result > 0) ){
        ~strdump("====== iterator ========");~dump(iterator);
        (cell cc, slice salt, slice pass) = load_salt_pass( s );
        if( are_slices_equal(in_s, salt) ){
            ~strdump("====== check_cell IF ========");
            result_slice = pass;
            result = 0;
        }
        s = cc.begin_parse();
        iterator = iterator + 1;
    }
    return result_slice;
}

(cell) write_cell( slice salt, slice pass, cell ref_cell ) inline {
    return begin_cell()
        .store_ref( ref_cell )
        .store_uint( slice_bits( salt ), 8 )
        .store_uint( slice_bits( pass ), 8 )
        .store_slice( salt )
        .store_slice( pass )
        .end_cell();
}

() save_data( slice in_salt, slice in_pass ) impure inline_ref {

    cell c = get_data();
    slice s = c.begin_parse();

    ;; выполняется только в самый первый раз
    int sr = slice_refs_empty?(s);
    ~strdump("====== sr ========");~dump(sr);
    if( slice_refs_empty?(s) ){
        ~strdump("====== first time salt ========");~strdump(in_salt);
        ~strdump("====== first time pass ========");~strdump(in_pass);
        cell cc = write_cell( in_salt, in_pass, begin_cell().end_cell() );
        set_data(cc);
    }
    else {
        ~strdump("====== second time ========");
        cell cc = write_cell( in_salt, in_pass, c );
        set_data(cc);
    }
    ;; cell cc = write_cell( in_salt, in_pass, c );
    ;; set_data(cc);
    ;; return ();
}

(cell) raw_msg_body( int comission, slice dest_address ) inline {
    return begin_cell()
        ;; .store_uint( 0, 1 ) ;; tag
        ;; .store_uint( 1, 1 ) ;; ihr_disabled
        ;; .store_uint( 1, 1 ) ;; allow bounces
        ;; .store_uint( 0, 1 ) ;; not bounced itself
        .store_uint( 0x18, 6 )
        .store_slice( dest_address )
        .store_coins( comission )
        .store_uint( 0, 1 + 4 + 4 + 64 + 32 + 1 + 1 )
        .store_uint( op::increase, 32 )
        ;; .store_uint( query_id, 64 )
        .end_cell();
}

;; recv_internal is the main function of the contract and is called when it receives a message
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if( in_msg_body.slice_empty?() ){
        return ();
    }

    slice cs = in_msg_full.begin_parse();

    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    int op = in_msg_body~load_uint(32); ;; by convention

    if (op == op::increase) { ;; handle op::increase

        int in_salt_bits = in_msg_body~load_uint(8);
        int in_pass_bits = in_msg_body~load_uint(8);
        slice pass = slice_last(in_msg_body, in_pass_bits);

        if( pass.slice_empty?() ) {
            return ();
        }

        in_msg_body~skip_last_bits(in_pass_bits);
        slice salt = slice_last(in_msg_body, in_salt_bits);

        if( salt.slice_empty?() ) {
            return ();
        }

        save_data( salt, pass );
        
        ;; int query_id = cs~load_uint(64);

        int comission_amount = msg_value / 3;
        ~strdump("====== comission_amount ========"); ~dump(comission_amount);

        ;; slice sender_address = cs~load_msg_addr();
        ;; ~strdump("====== sender_address ========");~strdump(sender_address);
        ;; ~strdump("====== dest_address_2 ========");~strdump(dest_address_2);
        cell msg1 = raw_msg_body( comission_amount, dest_address_1 );
        send_raw_message( msg1, 1 );

        cell msg2 = raw_msg_body( comission_amount, dest_address_2 );
        return send_raw_message( msg2, 1 );

        ;; throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
        ;; if the message is bounceable, the contract will then bounce the message to the sender
        ;; and the sender will receive unspent coins and will know that this message failed
        ;; provided of course that the sender has code to handle bounced messages
        ;; ~strdump("====== return () ========");
    }

    ~strdump("====== ERROR ========");
    throw(0xffff);
}

(cell) error_cell( slice error_msg ) inline {
    return begin_cell()
        .store_uint( slice_bits(error_msg), 8)
        .store_slice(error_msg)
        .end_cell();
}
;; get methods are a means to conveniently read contract data using, for example, HTTP APIs
;; they are marked with method_id
;; note that unlike in many other smart contract VMs, get methods cannot be called by other contracts
(cell) get_salt( cell payload_cell ) method_id {
    slice payload = payload_cell.begin_parse();
    if( payload.slice_empty?() ){
        return( error_cell( "payload_empty" ) );
    }

    int salt_bits = payload~load_uint(8);
    slice salt = slice_last( payload, salt_bits );
    ~strdump("====== get_salt salt ========"); ~strdump(salt);
    slice s = check_cell( salt );

    ~strdump("====== get_salt check_cell ========"); ~strdump(s);
    cell c = begin_cell()
        .store_uint( slice_bits(s), 8)
        .store_slice(s)
        .end_cell();
    return c; ;; then return the value
}
